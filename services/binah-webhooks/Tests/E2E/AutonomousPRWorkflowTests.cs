using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Xunit;
using Binah.Webhooks.Tests.Helpers;

namespace Binah.Webhooks.Tests.E2E;

/// <summary>
/// End-to-end tests for the complete autonomous PR creation workflow
/// These tests simulate the entire process from ontology refactoring to PR merge
///
/// Full workflow:
/// 1. User authorizes GitHub OAuth
/// 2. Service receives ontology refactoring request
/// 3. Service creates branch via GitHub API
/// 4. Service commits generated files via GitHub API
/// 5. Service creates PR via GitHub API
/// 6. Service receives webhook when PR is merged
/// 7. Service updates status in database
///
/// Prerequisites:
/// - GITHUB_TEST_TOKEN: Personal access token
/// - GITHUB_TEST_REPO: Test repository (owner/repo)
/// - RUN_GITHUB_TESTS=true
///
/// NOTE: These tests are skipped by default as they require GitHub credentials
/// and make real API calls to GitHub.
/// </summary>
[Collection("GitHub E2E Tests")]
public class AutonomousPRWorkflowTests : IDisposable
{
    private readonly GitHubTestHelper? _testHelper;
    private readonly bool _testsEnabled;

    public AutonomousPRWorkflowTests()
    {
        var testToken = Environment.GetEnvironmentVariable("GITHUB_TEST_TOKEN") ?? string.Empty;
        var testRepo = Environment.GetEnvironmentVariable("GITHUB_TEST_REPO") ?? string.Empty;
        var runTests = Environment.GetEnvironmentVariable("RUN_GITHUB_TESTS");

        _testsEnabled = !string.IsNullOrEmpty(testToken)
            && !string.IsNullOrEmpty(testRepo)
            && runTests?.ToLower() == "true";

        if (_testsEnabled)
        {
            _testHelper = new GitHubTestHelper(testToken, testRepo);
        }
    }

    [Fact(Skip = "Requires GitHub credentials and live API - set RUN_GITHUB_TESTS=true to enable")]
    public async Task E2E_OntologyRefactoring_CreatesBranchCommitsPR()
    {
        if (!_testsEnabled || _testHelper == null)
        {
            Assert.True(true, "Test skipped - credentials not provided");
            return;
        }

        // This test simulates the ontology refactoring workflow:
        // 1. Claude generates new YAML schema
        // 2. Binah-regen generates code from schema
        // 3. Service creates branch, commits files, creates PR

        try
        {
            // Step 1: Create branch (simulates binah-regen triggering GitHub API)
            var branchName = await _testHelper.CreateTestBranchAsync("claude/refactor-ontology");
            Assert.NotEmpty(branchName);

            // Step 2: Commit ontology YAML file (simulates generated schema)
            var yamlContent = @"# Test Ontology Schema
version: '1.0'
entities:
  TestEntity:
    description: 'Auto-generated test entity'
    properties:
      - name: TestProperty
        type: string
        required: true
";
            var yamlCommitSha = await _testHelper.CreateTestFileAsync(
                branchName,
                "schemas/test-ontology.yaml",
                yamlContent,
                "feat(ontology): Add auto-generated test entity");

            Assert.NotEmpty(yamlCommitSha);

            // Step 3: Commit generated code files (simulates binah-regen output)
            var generatedCodeContent = @"// Auto-generated by Binah.Regen
namespace Test.Domain
{
    public class TestEntity
    {
        public string TestProperty { get; set; }
    }
}
";
            var codeCommitSha = await _testHelper.CreateTestFileAsync(
                branchName,
                "services/binah-ontology/Models/Domain/TestEntity.cs",
                generatedCodeContent,
                "feat(ontology): Add generated TestEntity model");

            Assert.NotEmpty(codeCommitSha);

            // Step 4: Create PR with detailed description
            var prDescription = @"## Summary
ðŸ¤– **Autonomous PR** created by Binah platform

This PR contains ontology refactoring changes:
- âœ… New entity: `TestEntity`
- âœ… Generated domain model
- âœ… Updated YAML schema

## Changes
- `schemas/test-ontology.yaml` - New entity definition
- `services/binah-ontology/Models/Domain/TestEntity.cs` - Generated model

## Testing
- [ ] Schema validation passes
- [ ] Generated code compiles
- [ ] Integration tests pass

## Review Notes
This is an automated test PR. Safe to close after review.
";

            var prNumber = await _testHelper.CreateTestPullRequestAsync(
                branchName,
                null,
                "ðŸ¤– Auto-generated: Refactor ontology - Add TestEntity",
                prDescription);

            Assert.True(prNumber > 0);

            // Step 5: Verify PR was created successfully
            var pr = await _testHelper.AssertPullRequestExistsAsync(prNumber);
            Assert.NotNull(pr);
            Assert.Contains("Auto-generated", pr.Title);
            Assert.Contains("TestEntity", pr.Body);
            Assert.Equal("open", pr.State.StringValue);

            // At this point, a real workflow would:
            // - Receive webhook when PR is opened
            // - Store PR metadata in database
            // - Send notification to user
            // - Wait for review/approval
            // - Receive webhook when PR is merged
            // - Update ontology cache
            // - Trigger downstream services

            // Cleanup is handled automatically by Dispose()
        }
        catch (Exception ex)
        {
            Assert.True(false, $"E2E ontology refactoring test failed: {ex.Message}");
        }
    }

    [Fact(Skip = "Requires GitHub credentials and live API - set RUN_GITHUB_TESTS=true to enable")]
    public async Task E2E_CodeGeneration_CreatesBranchCommitsPR()
    {
        if (!_testsEnabled || _testHelper == null)
        {
            Assert.True(true, "Test skipped - credentials not provided");
            return;
        }

        // This test simulates the code generation workflow:
        // 1. User requests new feature via UI
        // 2. Binah-regen generates code
        // 3. Service creates PR with generated code

        try
        {
            // Step 1: Create branch
            var branchName = await _testHelper.CreateTestBranchAsync("claude/generate-feature");
            Assert.NotEmpty(branchName);

            // Step 2: Commit generated service files
            var serviceContent = @"using System;
using System.Threading.Tasks;

namespace Binah.Ontology.Services.Implementations
{
    /// <summary>
    /// Auto-generated service by Binah.Regen
    /// </summary>
    public class AutoGeneratedService
    {
        public async Task<string> ProcessAsync()
        {
            return await Task.FromResult(""Success"");
        }
    }
}
";
            var serviceCommitSha = await _testHelper.CreateTestFileAsync(
                branchName,
                "services/binah-ontology/Services/Implementations/AutoGeneratedService.cs",
                serviceContent,
                "feat(codegen): Add auto-generated service");

            Assert.NotEmpty(serviceCommitSha);

            // Step 3: Commit generated test files
            var testContent = @"using Xunit;

namespace Binah.Ontology.Tests
{
    /// <summary>
    /// Auto-generated tests by Binah.Regen
    /// </summary>
    public class AutoGeneratedServiceTests
    {
        [Fact]
        public async Task ProcessAsync_ReturnsSuccess()
        {
            var service = new AutoGeneratedService();
            var result = await service.ProcessAsync();
            Assert.Equal(""Success"", result);
        }
    }
}
";
            var testCommitSha = await _testHelper.CreateTestFileAsync(
                branchName,
                "services/binah-ontology/Tests/AutoGeneratedServiceTests.cs",
                testContent,
                "test(codegen): Add auto-generated service tests");

            Assert.NotEmpty(testCommitSha);

            // Step 4: Create PR
            var prDescription = @"## Summary
ðŸ¤– **Autonomous Code Generation**

This PR contains auto-generated code:
- âœ… Service implementation
- âœ… Unit tests
- âœ… All tests passing

## Generated Files
- `Services/Implementations/AutoGeneratedService.cs`
- `Tests/AutoGeneratedServiceTests.cs`

## Validation
- âœ… Code compiles
- âœ… Tests pass
- âœ… Follows project conventions

## Next Steps
- Review generated code
- Approve and merge
- Service will be available immediately
";

            var prNumber = await _testHelper.CreateTestPullRequestAsync(
                branchName,
                null,
                "ðŸ¤– Auto-generated: Add AutoGeneratedService",
                prDescription);

            Assert.True(prNumber > 0);

            // Step 5: Verify PR
            var pr = await _testHelper.AssertPullRequestExistsAsync(prNumber);
            Assert.NotNull(pr);
            Assert.Contains("AutoGeneratedService", pr.Title);
        }
        catch (Exception ex)
        {
            Assert.True(false, $"E2E code generation test failed: {ex.Message}");
        }
    }

    [Fact(Skip = "Requires GitHub credentials and live API - set RUN_GITHUB_TESTS=true to enable")]
    public async Task E2E_MultipleCommits_SinglePR()
    {
        if (!_testsEnabled || _testHelper == null)
        {
            Assert.True(true, "Test skipped - credentials not provided");
            return;
        }

        // Test creating multiple commits on a branch before creating PR

        try
        {
            var branchName = await _testHelper.CreateTestBranchAsync("multi-commit");

            // Commit 1
            await _testHelper.CreateTestFileAsync(
                branchName,
                "test-files/file1.txt",
                "Content 1",
                "feat: Add file 1");

            // Commit 2
            await _testHelper.CreateTestFileAsync(
                branchName,
                "test-files/file2.txt",
                "Content 2",
                "feat: Add file 2");

            // Commit 3
            await _testHelper.CreateTestFileAsync(
                branchName,
                "test-files/file3.txt",
                "Content 3",
                "feat: Add file 3");

            // Create PR with all commits
            var prNumber = await _testHelper.CreateTestPullRequestAsync(
                branchName,
                null,
                "Test: Multiple commits in single PR",
                "This PR contains 3 commits");

            Assert.True(prNumber > 0);

            var pr = await _testHelper.AssertPullRequestExistsAsync(prNumber);
            Assert.NotNull(pr);
        }
        catch (Exception ex)
        {
            Assert.True(false, $"E2E multi-commit test failed: {ex.Message}");
        }
    }

    [Fact(Skip = "Requires GitHub credentials and live API - set RUN_GITHUB_TESTS=true to enable")]
    public async Task E2E_ErrorHandling_InvalidBranchName()
    {
        if (!_testsEnabled || _testHelper == null)
        {
            Assert.True(true, "Test skipped - credentials not provided");
            return;
        }

        // Test error handling for invalid scenarios
        // In real workflow, service should handle errors gracefully

        await Assert.ThrowsAsync<Exception>(async () =>
        {
            // Try to commit to nonexistent branch
            await _testHelper.CreateTestFileAsync(
                "nonexistent-branch-12345",
                "test.txt",
                "content",
                "commit message");
        });
    }

    public void Dispose()
    {
        _testHelper?.Dispose();
    }
}
